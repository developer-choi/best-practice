## 문제
대부분의 페이지 이동 시 545ms가 걸리는 문제가 있었습니다. (대부분 SSR로 만든 페이지)

이 시간은 사용자가 어? 내가 링크를 안눌렀나? 라고 생각할 수 있는 시간입니다.

## 원인 분석 & 해결방법 채택

545ms 중에서 백엔드 API는 0.3초를 차지하는 상황이었습니다.

즉, INP (Interaction to Next Paint)를 먼저 개선하면 사용자의 불만을 크게 줄일 수 있을거라고 판단했습니다.

그래서, API 응답이 오지 않았어도 다음 페이지에 우선 보내주고

백엔드 API 응답이 될 때까지 로딩을 보여주는 방식을 채택했습니다.

이것을 실현할 수 있는 방법이 2가지 존재했습니다.

1. CSR: Tanstack Query 같은걸 사용하여 Client Side에서 데이터 패칭하고, 응답 전 까지 로딩 보여주기

2. Streaming: Server Side에서 데이터 패칭하고, (이하 동일)

## 비교: Non-interactive
대부분의 페이지에서 데이터가 패칭되는 환경은 전부 Non-interactive 했습니다.

데이터가 불러와지는 트리거가, 사용자가 더보기같은걸 클릭하거나 스크롤을 내리는 행위 같은게 없는 페이지들이었습니다.

이걸 Streaming 하게되면, CSR 대비 크게 2가지 장점이 존재했습니다.

[번들사이즈, 다운받는 시간 캡처 비교]

1. **백엔드 API 호출시점:** CSR보다 더 빠른 시점에 백엔드 API를 호출할 수 있습니다. 브라우저가 JS 다운받기 전에 벌써 Nextjs 서버에서 백엔드 API를 호출합니다.
2. **번들 사이즈:** Server Component도 사용가능하므로, 다운받아야할 JS 크기도 줄어듭니다.

## 비교: Cache
Tanstack Query도, Nextjs도 꽤 많은 Cache 관련 설정을 제공합니다.

Tanstack Query의 차별점은 다양한 refetching 기능을 제공합니다. (ex: Window focus event로 cache 최신화 하기)

하지만 캐시 데이터는 사용자의 브라우저에 저장됩니다.

Nextjs의 차별점은 Server Side에 Cache를 저장합니다. (Data Cache, Full Route Cache)

그런데, (저희가 구현했던) 대부분의 페이지는 private 페이지에, 자주바뀌는 데이터라는 특징이 있었고, 캐싱 기능이 불필요했습니다.

## 문제 해결
CSR이 단점을 상회하는 다른 장점이 없어서 Streaming으로 해결했습니다.

INP는 545ms에서 333ms로 39%가 개선되었습니다.

Server Component로 만들었기 때문에, CSR로 만들었던 페이지의 경우 번들사이즈가 48% 감소했습니다. (10.7kB > 5.5kB)

적용하는 방법도 짧고 간단해서 (커밋 링크) 10여개 페이지에 적용하는데 **30분**도 걸리지않았습니다.

# 다른 상황이라면 다른 방법이 나을까?

## 만약 public 페이지를 구현한다면?
미래에 학습자를 위한 사이트를 만들 예정에 있어서, 좀 더 검토를 진행했습니다.

모든 사용자에게 똑같은 데이터가 보이는 웹 페이지가 있다면,

CSR을 할 경우, 10만명의 사용자가 1번씩 접근하면 백엔드 API를 10만번 호출해야했습니다.

그대신 Data Cache / Full Route Cache를 사용하게 될 경우, 10억명이어도 백엔드 API 횟수는 1번으로 가능했습니다.
- 서버에서 캐시데이터를 들고있다가 모든 유저에게 제공하면 되기 때문

그러므로, public 페이지도 Streaming을 포함한 Server Side 방식이 우세해보였습니다.

## 그럼 Tanstack Query는 언제 써야하는가?
절대 Streaming 할 수 없는 경우에는 여전히 유효했습니다.

1. 더보기 버튼 눌러서 데이터 추가로 가져오기
2. 스크롤 더 내려서 다음 페이지 데이터 가져오기
3. Window Focus 이벤트가 발생하면 Background refetching 하기

브라우저에서만 발생하는 사용자의 이벤트는 당연히 Server에서 할 수 있는 일이 아닙니다.

# 정말로 이 방법이 올바른가?

제 뇌피셜이 아니라 합리적인 판단이었음을 출처로 보여드립니다.

## Nextjs 공식문서 링크 & 언급

## Tanstack Query 공식문서 링크 & 언급

# 다른 해결방법은 없었는가?
성능을 개선하는 방법은 정말 다양합니다.

렌더링 방식은 그중 하나일 뿐입니다.

웹 페이지가 브라우저에게 전달되고, 각종 리소스를 다운받는 그 전체 과정을 하나하나 전부 개선한다면

이론상 가장 빠른 웹페이지를 만들 수 있습니다.

그 방법들중 가장 쉽고, 효과가 큰것은 (제가 생각하기에) 렌더링 방식입니다.

성능 개선이라는 전체 카테고리중 렌더링 방식 하나밖에 경험을 못해봤기 떄문에, 더 많은 경험을 쌓고싶습니다.